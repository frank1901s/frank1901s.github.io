<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tacgib.club","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="这次软考准备匆忙，临时抱佛脚，整理此份临考笔记，希望有用。">
<meta property="og:type" content="article">
<meta property="og:title" content="软件设计师考试备考笔记">
<meta property="og:url" content="https://tacgib.club/2021/05/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="TACGIB CLUB">
<meta property="og:description" content="这次软考准备匆忙，临时抱佛脚，整理此份临考笔记，希望有用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621843244247.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621843860145.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621844908092.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621844889998.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621948636052.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621948603776.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621948783801.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949124405.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949915811.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949899258.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949844310.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949480913.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949516831.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949550281.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621951433093.png">
<meta property="og:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621952556068.png">
<meta property="article:published_time" content="2021-05-26T15:35:44.622Z">
<meta property="article:modified_time" content="2021-05-26T15:35:59.714Z">
<meta property="article:author" content="秋风木叶">
<meta property="article:tag" content="小书匠">
<meta property="article:tag" content="考试">
<meta property="article:tag" content="软件设计师">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621843244247.png">

<link rel="canonical" href="https://tacgib.club/2021/05/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>软件设计师考试备考笔记 | TACGIB CLUB</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TACGIB CLUB</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">云影时空</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">70</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">70</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tacgib.club/2021/05/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="秋风木叶">
      <meta itemprop="description" content="一片宁静自由的空间……">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TACGIB CLUB">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          软件设计师考试备考笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-26 23:35:44 / 修改时间：23:35:59" itemprop="dateCreated datePublished" datetime="2021-05-26T23:35:44+08:00">2021-05-26</time>
            </span>

          
            <span id="/2021/05/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="软件设计师考试备考笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这次软考准备匆忙，临时抱佛脚，整理此份临考笔记，希望有用。</p>
<a id="more"></a>

<h2 id="1-McCabe度量法计算环路复杂度"><a href="#1-McCabe度量法计算环路复杂度" class="headerlink" title="1. McCabe度量法计算环路复杂度"></a>1. McCabe度量法计算环路复杂度</h2><p>解法有三：</p>
<ul>
<li>流程图中的区域数等于环形复杂度；</li>
<li>流程图G的环形复杂度V(G)=E-N+2，其中E是流图中边的条数，N是节点数；</li>
<li>流图G的环形复杂度V(G)=P+1，其中P是流程图中<strong>判定节点</strong>的数目</li>
</ul>
<h2 id="2-测试用例覆盖"><a href="#2-测试用例覆盖" class="headerlink" title="2. 测试用例覆盖"></a>2. 测试用例覆盖</h2><p><strong>语句、条件、判定/条件、路径</strong></p>
<p><strong>逻辑覆盖率</strong>：语句覆盖&lt;条件覆盖&lt;判定覆盖&lt;条件-判定覆盖&lt;组合覆盖&lt;路径覆盖</p>
<p><strong>语句覆盖</strong>：设计用例，使程序中的每个可执行语句至少执行一次。<br><strong>条件覆盖</strong>：设计用例，使每个判断中的每个条件的可能取值至少满足一次。<br><strong>判定覆盖</strong>：设计用例，使得程序中的每一个判断的取真分支和取假分支至少经历一次。<br><strong>条件/判定覆盖</strong>：设计用例，使判定条件中的所有可能（条件成立、不成立）至少执行一次取值，同时，所有判断的可能结果（取真，取假），至少执行一次。<br><strong>组合覆盖</strong>：设计用例，使所有可能的条件取值组合至少执行一次。<br><strong>路径覆盖</strong>：设计测试用例，来覆盖程序中的所有可能执行的路径。</p>
<h2 id="3-依赖、泛化、关联、聚合、组合"><a href="#3-依赖、泛化、关联、聚合、组合" class="headerlink" title="3. 依赖、泛化、关联、聚合、组合"></a>3. 依赖、泛化、关联、聚合、组合</h2><p>UML中有4种关系：依赖、关联、泛化和实现</p>
<p><strong>依赖</strong>：两个事物减额的语义关系，其中一个事物发生变化会影响另一个事物的语义，是单向的，依赖关系用虚线加箭头表示</p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621843244247.png" alt="依赖关系"></p>
<p><strong>关联</strong>：是一种结构关联，描述了一组链，是对象之间的连接，<strong>聚合(聚集)</strong> 和 <strong>组合</strong>是特殊类型的关联。<em>在连接线的端点可以表示<strong>重复度</strong>（*表示多）</em></p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621843860145.png" alt="关联、聚集、组合"></p>
<p><strong>泛化</strong>：泛化是一种特殊/一般的关系，特殊元素（子元素）的对象可替代一般元素（父元素），子元素共享了父元素的结构和行为，用带有一个空心箭头的实线表示，箭头指向父元素。</p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621844908092.png" alt="泛化"></p>
<p><strong>实现</strong>：实现是类元之间的语义关系，其中一个类元指向另一个类元保证执行的契约。一种是在接口和实现他们的类或构件之间；另一种是在用例和实现他们的协作之间，用带有空心箭头的虚线表示。</p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621844889998.png" alt="实现"></p>
<h2 id="4-动态绑定、静态绑定"><a href="#4-动态绑定、静态绑定" class="headerlink" title="4. 动态绑定、静态绑定"></a>4. 动态绑定、静态绑定</h2><p><strong>绑定</strong>：就是一个方法的调用与调用这个方法的类连接在一起的过程被称为绑定。</p>
<p><strong>静态绑定</strong>，也叫前期绑定、编译时绑定<br><strong>动态绑定</strong>，也叫后期绑定、运行时绑定</p>
<h2 id="5-UML活动图、状态图、顺序图、类图"><a href="#5-UML活动图、状态图、顺序图、类图" class="headerlink" title="5. UML活动图、状态图、顺序图、类图"></a>5. UML活动图、状态图、顺序图、类图</h2><p>调用—–→<br>返回- - - →</p>
<p><strong>类图</strong>：展现了一组对象、接口、协作和他们之间的关系。类图包含：</p>
<ul>
<li>类；</li>
<li>接口；</li>
<li>协作；</li>
<li>依赖、泛化和关联关系。</li>
</ul>
<p>下列情况使用类图：</p>
<ul>
<li>对系统的词汇建模；</li>
<li>对简单的协作建模；</li>
<li>对逻辑数据库模式建模。</li>
</ul>
<p><strong>对象图</strong>：展现了某一时刻一组对象以及他们之间的关系，描述了在类图中所建立的事务的实例的静态快照。对象图包括：</p>
<ul>
<li>对象；</li>
<li>链。</li>
</ul>
<p>多用于<strong>静态数据结构建模</strong>。</p>
<p><strong>用例图</strong>：展现了一组用例、参与者以及他们之间的关系。</p>
<ul>
<li>用例图包括：</li>
<li>用例；</li>
<li>参与者；</li>
<li>用例之间的扩展关系和包含关系，参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系。</li>
</ul>
<p>可在下列两种方式使用用例图：</p>
<ul>
<li>对系统的语境建模；</li>
<li>对系统的需求建模。</li>
</ul>
<p><strong>交互图</strong>：用于对系统的动态方面进行建模。一般包括：</p>
<ul>
<li>对象；</li>
<li>链；</li>
<li>消息。</li>
</ul>
<p><em>序列图、通信图、交互概览图、计时图</em></p>
<p><strong>状态图</strong>：展示了一个状态机，由<u>状态、转换、事件</u>和<u>活动</u>组成，状态分为<u>简单状态</u>和<u>组合状态</u>。</p>
<p>状态图关注系统的动态试图，对于接口、类和写作的行为建模尤为重要，强调对象行为的事件顺序。</p>
<p><strong>活动图</strong>：一种特殊的状态图，它揭晓了在系统内从一个活动到另一个活动的流程。活动图专注于系统的动态试图，他对于系统的功能建模特别重要，并强调对象间的控制流程。</p>
<p>活动图一般包括：活动状态和动作状态、转换、对象。</p>
<p>通常有以下两种使用活动图的情况：</p>
<ul>
<li>对工作流建模；</li>
<li>对操作建模。此时将活动图当做流程图使用。</li>
</ul>
<p><strong>构件图</strong>：展现了一些构件之间的组织和依赖。构件图专注于系统的静态实现视图。通常把构建映射为一个或多个类、接口或写作。</p>
<p><strong>组合结构图</strong>：用于描述一个分类器（如类、构建或用例）的内部结构，分类器与系统中其他组成部分之间的交互接口，展示一组相互协作的实例如何完成特定的任务，描述设计、架构模式或策略。</p>
<p><strong>部署图</strong>：对面向对象系统的物理方面建模的方法，展现了运行时处理结点及其中间件（制品）的配置。部署图对系统的静态部署视图进行建模，他与构件图相关。通常，一个结点是一个运行时存在并代表一项计算资源的物理元素，至少拥有一些内容，常常具有处理能力，包含一个或多个构件。</p>
<p><strong>包图</strong>：用于把模型本身组织或层次结构的通用机制，不能执行，展现由模型本身分解而成的组织单元以及其间的依赖关系。</p>
<p>一个元素只能被一个包所拥有，拥有关系的包形成了一个命名空间，其中同一种元素的名称必须唯一。</p>
<h2 id="6-创建型模式、行为模式"><a href="#6-创建型模式、行为模式" class="headerlink" title="6. 创建型模式、行为模式"></a>6. 创建型模式、行为模式</h2><p><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">原文链接</a></p>
<h3 id="6-1-创建型模式"><a href="#6-1-创建型模式" class="headerlink" title="6.1 创建型模式"></a>6.1 创建型模式</h3><p>创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。</p>
<p><strong>工厂方法Factory Method</strong><br>在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。</p>
<p><strong>抽象工厂Abstract Factory</strong><br>让你能创建一系列相关的对象， 而无需指定其具体类。</p>
<p><strong>生成器Builder</strong><br>使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>
<p><strong>原型Prototype</strong><br>让你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>
<p><strong>单例Singleton</strong><br>让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>
<h3 id="6-2-行为模式"><a href="#6-2-行为模式" class="headerlink" title="6.2 行为模式"></a>6.2 行为模式</h3><p><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">行为模式</a>负责对象间的高效沟通和职责委派。</p>
<p><strong>责任链Chain of Responsibility</strong><br>允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>
<p><strong>命令Command</strong><br>它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<p><strong>迭代器Iterator</strong><br>让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<p><strong>中介者Mediator</strong><br>能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p>
<p><strong>备忘录Memento</strong><br>允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p>
<p><strong>观察者Observer</strong><br>允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p>
<p><strong>状态State</strong><br>让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p>
<p><strong>策略Strategy</strong><br>能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p>
<p><strong>模板方法Template Method</strong><br>在超类中定义一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p>
<p><strong>访问者Visitor</strong><br>将算法与其所作用的对象隔离开来。</p>
<h2 id="7-适配器模式、装饰器模式"><a href="#7-适配器模式、装饰器模式" class="headerlink" title="7. 适配器模式、装饰器模式"></a>7. 适配器模式、装饰器模式</h2><p>结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</p>
<p><strong>适配器Adapter</strong><br>让接口不兼容的对象能够相互合作。</p>
<p><strong>桥接Bridge</strong><br>可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p>
<p><strong>组合Composite</strong><br>你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<p><strong>装饰Decorator</strong><br>允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<p><strong>外观Facade</strong><br>能为程序库、 框架或其他复杂类提供一个简单的接口。</p>
<p><strong>享元Flyweight</strong><br>摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<p><strong>代理Proxy</strong><br>让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<h2 id="8-上下文无关文法"><a href="#8-上下文无关文法" class="headerlink" title="8. 上下文无关文法"></a>8. 上下文无关文法</h2><p>只要文法的定义里有某个产生式，不管一个非终结符前后的串是什么，就可以应用相应的产生式进行推导。</p>
<h2 id="9-a-0-c-b-a-编译时不报错，执行时异常"><a href="#9-a-0-c-b-a-编译时不报错，执行时异常" class="headerlink" title="9. a=0, c=b/a, 编译时不报错，执行时异常"></a>9. a=0, c=b/a, 编译时不报错，执行时异常</h2><h2 id="10-数据库，先写入日志，再写入数据文件，故障时恢复"><a href="#10-数据库，先写入日志，再写入数据文件，故障时恢复" class="headerlink" title="10. 数据库，先写入日志，再写入数据文件，故障时恢复"></a>10. 数据库，先写入日志，再写入数据文件，故障时恢复</h2><h2 id="11-查员工数大于2的部门的平均工资"><a href="#11-查员工数大于2的部门的平均工资" class="headerlink" title="11. 查员工数大于2的部门的平均工资"></a>11. 查员工数大于2的部门的平均工资</h2><p>select 部门, avg(应发工资) as 平均工资 from 工资表 group by 部门 having count(姓名) &gt; 2;</p>
<h2 id="12-事务原子性、一致性、隔离性和持久性"><a href="#12-事务原子性、一致性、隔离性和持久性" class="headerlink" title="12. 事务原子性、一致性、隔离性和持久性"></a>12. 事务原子性、一致性、隔离性和持久性</h2><p>事务是指对系统进行的一组操作，为了保证系统的完整性，事务需要具有ACID特性，具体如下：</p>
<p><strong>原子性（Atomic）</strong></p>
<p>一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。实现事务的原子性，要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。</p>
<p>回滚实际上是一个比较高层抽象的概念，大多数DB在实现事务时，是在事务操作的数据快照上进行的（比如，MVCC），并不修改实际的数据，如果有错并不会提交，所以很自然的支持回滚。</p>
<p>而在其他支持简单事务的系统中，不会在快照上更新，而直接操作实际数据。可以先预演一边所有要执行的操作，如果失败则这些操作不会被执行，通过这种方式很简单的实现了原子性。</p>
<p><strong>一致性（Consistency）</strong></p>
<p> 一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性：</p>
<ul>
<li>强一致性：读操作可以立即读到提交的更新操作。</li>
<li>弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。</li>
<li>最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。</li>
</ul>
<p>其他一致性变体还有：</p>
<ul>
<li>单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。</li>
<li>会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。</li>
</ul>
<p><strong>隔离性（Isolation）</strong></p>
<p>并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据。在事务并发操作时，可能出现的问题有：</p>
<ul>
<li>脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。</li>
<li>不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。 不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。</li>
<li>幻读：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。 幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。</li>
</ul>
<p>事务的隔离级别从低到高有：</p>
<ul>
<li>Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</li>
<li>Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。 可以解决脏读问题。</li>
<li>Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。 可以解决脏读、不可重复读。</li>
<li>Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。 可以解决并发事务的所有问题。</li>
</ul>
<p>通常，在工程实践中，为了性能的考虑会对隔离性进行折中。</p>
<p><strong>持久性（Durability）</strong></p>
<p>事务提交后，对系统的影响是永久的。</p>
<h2 id="13-时间复杂度计算"><a href="#13-时间复杂度计算" class="headerlink" title="13.时间复杂度计算"></a>13.时间复杂度计算</h2><p>时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。</p>
<p>Ο(1) ＜ Ο(log2n) ＜ Ο(n) ＜ Ο(nlog2n) ＜ Ο(n²) ＜ Ο(n³) ＜…＜ Ο(2^n) ＜ Ο(n!) &lt; O(n^n)</p>
<p>对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n*m)。</p>
<p>对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n*a*b*c…)。</p>
<p>对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。</p>
<p>对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。</p>
<p><strong>T(n) = T(n-1) + n</strong><br>=T(n-1) + n<br>=T(n-2)+(n-1) + n<br>=T(n-3)+(n-2)+(n-1) + n<br>…<br>=T(0)+1+2+…+(n-2)+(n-1) + n<br>=1+1+2+…+(n-2)+(n-1) + n<br>=1+(n+1)*n/2</p>
<p>所以为 O(n²)</p>
<h2 id="14-Prim、Kruskal算法"><a href="#14-Prim、Kruskal算法" class="headerlink" title="14. Prim、Kruskal算法"></a>14. Prim、Kruskal算法</h2><p>一开始，将初始点作为生成树团块的唯一成员，然后，从团块通向团块外（团块中没有的点）的边中选择一条最短的，并将其通向的点加入生成树团块，重复这一过程，直至生成树团块包含了整个图。</p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621948636052.png" alt="Prim"></p>
<p>“加边”：图有n个点，将图中所有边取出按边权排序，这时图中只有点，没有边，然后从最小的开始再放回图中，放入后不成环就可以留下，不然就拿走，就这样一直放，直到放进去了n-1条边，结束。此时，图中会形成一棵树，便是最小生成树，其总路径就是放进去留下的边的边权之和。</p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621948603776.png" alt="Kruskal"></p>
<h2 id="15-DFD数据流"><a href="#15-DFD数据流" class="headerlink" title="15. DFD数据流"></a>15. DFD数据流</h2><p>数据流图（DFD）：用处理、外部实体、数据流以及数据存储来表示系统需求的图表</p>
<p>DFD的特点：</p>
<ul>
<li>图形元素少且符号简单易懂</li>
<li>较充分表达系统的主要需求：输入、输出、处理和数据存储</li>
<li>最终用户、管理人员和系统开发人员只需稍加培训即可读懂DFD图，方便交流</li>
</ul>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621948783801.png" alt="数据流图1"></p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949124405.png" alt="数据流图2"></p>
<h2 id="16-数据库设计-实体联系图"><a href="#16-数据库设计-实体联系图" class="headerlink" title="16. 数据库设计 实体联系图"></a>16. 数据库设计 实体联系图</h2><p><a href="https://blog.csdn.net/yangjie123_/article/details/102766929" target="_blank" rel="noopener">点击前往原文链接</a><br>实体关系图（Entity Relation Diagram，ERD），用于数据库设计的结构图，描述系统内的实体以及实体之间的关系。</p>
<p>ER图包含实体、属性和关系。</p>
<p> <strong>实体</strong>是一个系统内可定义的事物或概念，对应数据库中的表，如人/角色（例如学生），对象（例如发票），概念（例如简介）或事件（例如交易）。在 ER 模型中，实体用矩形表示，其名称位于上方，其属性列在实体形状的主体中。</p>
<p><strong>属性</strong>也称为列、字段。一个属性包括属性名、类型以及长度、是否可为空，以及主键、外键等标识。</p>
<p>主键（Primary Key，PK），是一种特殊的实体属性，用于界定数据库表中的记录的独特性，一个表只能拥有一个主键。</p>
<p>外键（Foreign Key，FK），是对主键的引用，用于识别实体之间的关系。一个表的外键可以有多个，且多个记录可以共享相同的外键值。下面的 ERD 示例展示了实体中的外键引用另一个实体。</p>
<p><strong>关系</strong>，两个实体之间的关系包括1对1,1对多和多对多。</p>
<p>1对1：主要用于将实体分成两部分，简洁地将资讯呈现，使读者更容易理解。</p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949915811.png" alt="1对1关系"></p>
<p>1对多：X 的一个实例可以链接到Y的许多实例，而 Y 的一个实例仅链接到 X 的一个实例。</p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949899258.png" alt="一对多关系"></p>
<p>多对多：在设计数据库时，多对多关系通过一个操作的实体被分成两个一对多的关系，如下图学生与课程之间是多对多关系，通过增加一个“选课”操作实体，转变为两个一对多关系。</p>
<p>示例：</p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949844310.png" alt="多对多关系"></p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949480913.png" alt="电影租赁系统"></p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949516831.png" alt="贷款系统"></p>
<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621949550281.png" alt="在线商店"></p>
<h2 id="17-协作图（通信图）"><a href="#17-协作图（通信图）" class="headerlink" title="17. 协作图（通信图）"></a>17. 协作图（通信图）</h2><p>通信图的概念：通信图（协作图）是表现对象交互关系的图，它展现了多个对象在协同工作达成共同目标的过程中互相通信的情况，通过对象和对象之间的链、发送的消息来显示参与交互的对象。</p>
<p>是一种交互图，它描述的是对象和对象之间的关系，即一个类操作的实现。简而言之就是，对象和对象之间的调用关系，体现的是一种组织关系。</p>
<h2 id="18-策略模式、观察者模式"><a href="#18-策略模式、观察者模式" class="headerlink" title="18. 策略模式、观察者模式"></a>18. 策略模式、观察者模式</h2><p><a href="https://refactoringguru.cn/design-patterns/strategy" target="_blank" rel="noopener">策略模式</a>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p>
<p>当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。</p>
<p><a href="https://refactoringguru.cn/design-patterns/visitor" target="_blank" rel="noopener">访问者模式</a>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p>
<p>如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。</p>
<h2 id="19-归并排序、插入排序"><a href="#19-归并排序、插入排序" class="headerlink" title="19. 归并排序、插入排序"></a>19. 归并排序、插入排序</h2><p><a href="https://zhuanlan.zhihu.com/p/124356219" target="_blank" rel="noopener">归并排序</a>，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序（C-迭代版）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a = arr;</span><br><span class="line">    <span class="keyword">int</span>* b = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg + seg, len);</span><br><span class="line">            <span class="keyword">int</span> k = low;</span><br><span class="line">            <span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>* temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序（C-递归版）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">end</span> - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = <span class="built_in">end</span>;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= <span class="built_in">end</span>; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621951433093.png" alt="归并排序"></p>
<p><a href="https://zhuanlan.zhihu.com/p/122293204" target="_blank" rel="noopener">插入排序</a>的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>插入排序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查数据合法性</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="comment">//如果比tmp大把值往后移动一位</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; tmp)&#123;</span><br><span class="line">               arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="20-算法复杂度"><a href="#20-算法复杂度" class="headerlink" title="20. 算法复杂度"></a>20. 算法复杂度</h2><p>时间、空间</p>
<h2 id="21-数值表示"><a href="#21-数值表示" class="headerlink" title="21. 数值表示"></a>21. 数值表示</h2><h2 id="22-程序计数器"><a href="#22-程序计数器" class="headerlink" title="22. 程序计数器"></a>22. 程序计数器</h2><p>程序计数器是用于存放下一条指令所在单元的地址的地方。</p>
<h2 id="23-可靠度计算"><a href="#23-可靠度计算" class="headerlink" title="23. 可靠度计算"></a>23. 可靠度计算</h2><p>串联：R = R1*R2…Rn</p>
<p>并联：R = 1 - (1-R1)*(1-R2)…(1-Rn)</p>
<p>串联+并联都有：把并联的看作一个整体，再用串联的方法</p>
<h2 id="24-外部实体"><a href="#24-外部实体" class="headerlink" title="24. 外部实体"></a>24. 外部实体</h2><p>外部实体（External Entities）又称外部项，是指独立于系统而存在的，但又和系统有联系的实体，它表示数据的外部来源和最后去向。 例如顾客、仓库、查询者等。</p>
<h2 id="25-PV操作"><a href="#25-PV操作" class="headerlink" title="25. PV操作"></a>25. PV操作</h2><p>P(x)：检查上一个进程是否完成<br>V(x)：唤醒当前进程指向下一个进程</p>
<h2 id="26-算法设计策略"><a href="#26-算法设计策略" class="headerlink" title="26. 算法设计策略"></a>26. 算法设计策略</h2><p>贪心、动态规划</p>
<p>将原问题分解成若干个子问题。与分治法不同的是，其分解出的子问题往往不是相互独立的。这种情况下若用分治法会对一些子问题进行多次求解，这显然是不必要的。动态规划法在求解过程中把所有已解决的子问题的答案保存起来，从而避免对子问题重复求解。</p>
<p>贪心法总是做出在当前看来最好的选择，也就是说贪心法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。</p>
<h2 id="27-二叉排序树遍历"><a href="#27-二叉排序树遍历" class="headerlink" title="27. 二叉排序树遍历"></a>27. 二叉排序树遍历</h2><p><strong>前序</strong>；先访问根节点，然后从左到右遍历根节点的各棵子树<br><strong>后序</strong>：先从左到右遍历根节点的各棵子树，然后访问根节点<br><strong>层序</strong>：先访问处于1层上的节点，然后从左到右以此访问处于2层上的节点，以此类推，自上而下，自左至右逐层访问树各层上的节点</p>
<h2 id="28-矩阵顶点、有向图、无向图、广度优先遍历序列"><a href="#28-矩阵顶点、有向图、无向图、广度优先遍历序列" class="headerlink" title="28. 矩阵顶点、有向图、无向图、广度优先遍历序列"></a>28. 矩阵顶点、有向图、无向图、广度优先遍历序列</h2><h2 id="29-关系代数表达式"><a href="#29-关系代数表达式" class="headerlink" title="29. 关系代数表达式"></a>29. 关系代数表达式</h2><p>关系代数中包括了：并、交、差、乘、选择、投影、联接、除、自然联接等操作。</p>
<p>五个基本操作：并(∪)、差(-)、笛卡尔积(×)、投影(π)、选择(σ)</p>
<p>四个组合操作：交(∩)、联接(等值联接)、自然联接(RcrossS)、除法(÷) </p>
<h2 id="30-关系模式"><a href="#30-关系模式" class="headerlink" title="30. 关系模式"></a>30. 关系模式</h2><h2 id="31-不确定有限自动机（NFA）状态转换图"><a href="#31-不确定有限自动机（NFA）状态转换图" class="headerlink" title="31. 不确定有限自动机（NFA）状态转换图"></a>31. 不确定有限自动机（NFA）状态转换图</h2><p><a href="https://www.cnblogs.com/Bubgit/p/10240790.html" target="_blank" rel="noopener">什么是NFA(不确定的有穷自动机)和DFA(确定的有穷自动机)</a></p>
<h2 id="32-类图、组件图、通信图、部署图"><a href="#32-类图、组件图、通信图、部署图" class="headerlink" title="32. 类图、组件图、通信图、部署图"></a>32. 类图、组件图、通信图、部署图</h2><h2 id="33-过载多态"><a href="#33-过载多态" class="headerlink" title="33. 过载多态"></a>33. 过载多态</h2><h2 id="34-存储空间题目"><a href="#34-存储空间题目" class="headerlink" title="34. 存储空间题目"></a>34. 存储空间题目</h2><p>内存按字节编址，若用存储容量为32K * 8bit的存储器芯片构成地址从A0000H到DFFFFH的内存，则至少需要多少芯片？</p>
<p>因为，DFFFFH-AFFFFH=3FFFFH ≈ 40000H = 2^18B<br>又因为，32K = 32 * 2^10<br>所以，2^18 / (32 * 2^10) = 2^8 / 32 = 8</p>
<h2 id="35-文件索引题目"><a href="#35-文件索引题目" class="headerlink" title="35. 文件索引题目"></a>35. 文件索引题目</h2><p>文件系统采用多级索引结构，磁盘块大小为1K字节，每块3字节，二级索引时最大文件长度为：(1024 / 3) = 341^2，一级为：1024 /3 = 341</p>
<h2 id="36-极限编程的12个最佳实践"><a href="#36-极限编程的12个最佳实践" class="headerlink" title="36. 极限编程的12个最佳实践"></a>36. 极限编程的12个最佳实践</h2><p><strong>（1）计划游戏 ( Planning Game )</strong></p>
<p>快速制定计划、随着细节的不断变化而完善；</p>
<p><strong>详解</strong>：要求结合项目进展和技术情况，确定下一阶段要开发与发布的系统范围。当计划赶不上实际变化时就应更新计划。</p>
<p><strong>（2）小型发布 ( Small Release )</strong></p>
<p>系统的设计要能够尽可能早地交付；</p>
<p><strong>详解</strong>：强调在非常短的周期内以递增的方式发布新版本，从而可以很容易地估计每个迭代周期的进度，便于控制工作量和风险；同时，也可以及时处理用户的反馈。</p>
<p><strong>（3）系统隐喻( System Metaphor )</strong></p>
<p>找到合适的比喻传达信息；</p>
<p><strong>详解</strong>：通过隐喻来描述系统如何运作、新的功能以何种方式加入到系统。它通常包含了一些可以参照和比较的类和设计模式。</p>
<p><strong>（4）简单设计( Simple Design )</strong></p>
<p>只处理当前的需求使设计保持简单；</p>
<p><strong>详解</strong>：任何时候都应当将系统设计的尽可能简单。不必要的复杂性一旦被发现就马上去掉。</p>
<p><strong>（5）测试驱动( Test-driven )</strong></p>
<p>先写测试代码再编写程序；</p>
<p><strong>详解</strong>：程序员不断地编写单元测试，在这些测试能够准确无误地运行的情况下开发才可以继续。</p>
<p><strong>（6）重构( Refactoring )</strong></p>
<p>重新审视需求和设计，重新明确地描述它们，以符合新的和现有的需求；</p>
<p><strong>详解</strong>：代码重构是指在不改变系统行为的前提下，重新调整、优化系统的内部结构以减少复杂性、消除冗余、增加灵活性和提高性能。</p>
<p><strong>（7）结对编程( Pair Programming )</strong></p>
<p>由两个程序员在同一台电脑上共同编写解决同一问题的代码。</p>
<p><strong>详解</strong>：通常一个人负责写编码，而另一个负责保证代码的正确性与可读性。 </p>
<p><strong>（8）集体所有权（Collective Ownership）</strong></p>
<p>任何人在任何时候都可以在系统中的任何位置更改任何代码。</p>
<p><strong>详解</strong>：每个成员都有更改代码的权利，所有的人对于全部代码负责。</p>
<p><strong>（9）持续集成( Continuous Integration )</strong></p>
<p>可以按日甚至按小时为客户提供可运行的版本；</p>
<p>提倡在一天中集成系统多次，而且随着需求的改变，要不断的进行回归测试，避免了一次系统集成的恶梦。</p>
<p><strong>（10）每周工作40小时 ( 40-hour Week )</strong></p>
<p>要求项目团队人员每周工作时间不能超过40小时，加班不得连续超过两周，否则反而会影响生产率。</p>
<p><strong>（11）现场客户( On-site Customer )</strong></p>
<p>在团队中加入一位真正的、起作用的用户，他将全职负责回答问题。</p>
<p><strong>详解</strong>：要求至少有一名实际的客户代表在整个项目开发周期在现场负责确定需求、回答团队问题以及编写功能验收测试。</p>
<p><strong>（12）编码标准( Code Standards )</strong></p>
<p>强调通过指定严格的代码规范来进行沟通，尽可能减少不必要的文档。</p>
<h2 id="37-管道过滤器不支持批处理和并发控制"><a href="#37-管道过滤器不支持批处理和并发控制" class="headerlink" title="37. 管道过滤器不支持批处理和并发控制"></a>37. 管道过滤器不支持批处理和并发控制</h2><h2 id="38-名词短语、动词短语"><a href="#38-名词短语、动词短语" class="headerlink" title="38. 名词短语、动词短语"></a>38. 名词短语、动词短语</h2><p>名词短语暗示类及其属性；<br>动词短语暗示其职责或操作。</p>
<h2 id="39-三级结构-两级映像的数据库体系结构"><a href="#39-三级结构-两级映像的数据库体系结构" class="headerlink" title="39. 三级结构 | 两级映像的数据库体系结构"></a>39. 三级结构 | 两级映像的数据库体系结构</h2><p>用户模式、外模式、内模式、模式、内模式</p>
<h2 id="40-插入、快速、归并、堆排序的时间复杂度"><a href="#40-插入、快速、归并、堆排序的时间复杂度" class="headerlink" title="40. 插入、快速、归并、堆排序的时间复杂度"></a>40. 插入、快速、归并、堆排序的时间复杂度</h2><p><img src="http://zhengjie.ren/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621952556068.png" alt="排序算法复杂度"></p>
<h2 id="41-无向图"><a href="#41-无向图" class="headerlink" title="41.无向图"></a>41.无向图</h2><p>任意两个顶点之间存在路径<br>任意顶点出发可遍历图中所有顶点<br>邻接矩阵是对称矩阵</p>
<h2 id="42-哈夫曼树（最优二叉树）"><a href="#42-哈夫曼树（最优二叉树）" class="headerlink" title="42. 哈夫曼树（最优二叉树）"></a>42. 哈夫曼树（最优二叉树）</h2><p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：</p>
<ul>
<li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li>
<li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li>
<li>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li>
</ul>
<h2 id="43-JDBC"><a href="#43-JDBC" class="headerlink" title="43. JDBC"></a>43. JDBC</h2><p>JDBC 指 Java 数据库连接，是一种标准Java应用编程接口（ JAVA API），用来连接 Java 编程语言和广泛的数据库。</p>
<p>从根本上来说，JDBC 是一种规范，它提供了一套完整的接口，允许便携式访问到底层数据库，因此可以用 Java 编写不同类型的可执行文件，</p>
<hr>
<p>文章使用小书匠MarkDown编辑器书写，大家可以通过本站<a href="https://tacgib.club/2019/07/06/小书匠邀请码/">小书匠邀请码</a>一文获取<strong>邀请码</strong>及<strong>下载链接</strong>。</p>
<hr>
<center>秋风木叶</center>
<center>2021-5-22</center>
    </div>

    
    
    
        <div class="reward-container">
  <div>有您的赞赏，我会更加有动力！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="http://zhengjie.ren/小书匠/1587477501749.png21" alt="秋风木叶 支付宝">
        <p>支付宝</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="http://zhengjie.ren/小书匠/1615647836412.png" alt="秋风木叶 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>秋风木叶
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://tacgib.club/2021/05/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0/" title="软件设计师考试备考笔记">https://tacgib.club/2021/05/26/软件设计师考试备考笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B0%8F%E4%B9%A6%E5%8C%A0/" rel="tag"># 小书匠</a>
              <a href="/tags/%E8%80%83%E8%AF%95/" rel="tag"># 考试</a>
              <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/" rel="tag"># 软件设计师</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/26/%E6%AD%A5%E5%85%A5%E6%AD%A3%E8%BD%A8/" rel="prev" title="步入正轨">
      <i class="fa fa-chevron-left"></i> 步入正轨
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/02/%E9%87%8D%E5%A4%A7%E6%B4%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" rel="next" title="重大活动网络安全保障注意事项">
      重大活动网络安全保障注意事项 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-McCabe度量法计算环路复杂度"><span class="nav-text">1. McCabe度量法计算环路复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-测试用例覆盖"><span class="nav-text">2. 测试用例覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-依赖、泛化、关联、聚合、组合"><span class="nav-text">3. 依赖、泛化、关联、聚合、组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-动态绑定、静态绑定"><span class="nav-text">4. 动态绑定、静态绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-UML活动图、状态图、顺序图、类图"><span class="nav-text">5. UML活动图、状态图、顺序图、类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-创建型模式、行为模式"><span class="nav-text">6. 创建型模式、行为模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-创建型模式"><span class="nav-text">6.1 创建型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-行为模式"><span class="nav-text">6.2 行为模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-适配器模式、装饰器模式"><span class="nav-text">7. 适配器模式、装饰器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-上下文无关文法"><span class="nav-text">8. 上下文无关文法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-a-0-c-b-a-编译时不报错，执行时异常"><span class="nav-text">9. a&#x3D;0, c&#x3D;b&#x2F;a, 编译时不报错，执行时异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-数据库，先写入日志，再写入数据文件，故障时恢复"><span class="nav-text">10. 数据库，先写入日志，再写入数据文件，故障时恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-查员工数大于2的部门的平均工资"><span class="nav-text">11. 查员工数大于2的部门的平均工资</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-事务原子性、一致性、隔离性和持久性"><span class="nav-text">12. 事务原子性、一致性、隔离性和持久性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-时间复杂度计算"><span class="nav-text">13.时间复杂度计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-Prim、Kruskal算法"><span class="nav-text">14. Prim、Kruskal算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-DFD数据流"><span class="nav-text">15. DFD数据流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-数据库设计-实体联系图"><span class="nav-text">16. 数据库设计 实体联系图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-协作图（通信图）"><span class="nav-text">17. 协作图（通信图）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-策略模式、观察者模式"><span class="nav-text">18. 策略模式、观察者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-归并排序、插入排序"><span class="nav-text">19. 归并排序、插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-算法复杂度"><span class="nav-text">20. 算法复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-数值表示"><span class="nav-text">21. 数值表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-程序计数器"><span class="nav-text">22. 程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-可靠度计算"><span class="nav-text">23. 可靠度计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-外部实体"><span class="nav-text">24. 外部实体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-PV操作"><span class="nav-text">25. PV操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-算法设计策略"><span class="nav-text">26. 算法设计策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-二叉排序树遍历"><span class="nav-text">27. 二叉排序树遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-矩阵顶点、有向图、无向图、广度优先遍历序列"><span class="nav-text">28. 矩阵顶点、有向图、无向图、广度优先遍历序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-关系代数表达式"><span class="nav-text">29. 关系代数表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-关系模式"><span class="nav-text">30. 关系模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-不确定有限自动机（NFA）状态转换图"><span class="nav-text">31. 不确定有限自动机（NFA）状态转换图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-类图、组件图、通信图、部署图"><span class="nav-text">32. 类图、组件图、通信图、部署图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-过载多态"><span class="nav-text">33. 过载多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-存储空间题目"><span class="nav-text">34. 存储空间题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-文件索引题目"><span class="nav-text">35. 文件索引题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-极限编程的12个最佳实践"><span class="nav-text">36. 极限编程的12个最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-管道过滤器不支持批处理和并发控制"><span class="nav-text">37. 管道过滤器不支持批处理和并发控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-名词短语、动词短语"><span class="nav-text">38. 名词短语、动词短语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-三级结构-两级映像的数据库体系结构"><span class="nav-text">39. 三级结构 | 两级映像的数据库体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-插入、快速、归并、堆排序的时间复杂度"><span class="nav-text">40. 插入、快速、归并、堆排序的时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-无向图"><span class="nav-text">41.无向图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-哈夫曼树（最优二叉树）"><span class="nav-text">42. 哈夫曼树（最优二叉树）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-JDBC"><span class="nav-text">43. JDBC</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">秋风木叶</p>
  <div class="site-description" itemprop="description">一片宁静自由的空间……</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://tacgib.club/" title="https:&#x2F;&#x2F;tacgib.club">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">秋风木叶</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'JPt4HeuQbSMjT4cQoLKEphX7-gzGzoHsz',
      appKey     : 'J2t8poEMDg21tmRTFirjHgqx',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
